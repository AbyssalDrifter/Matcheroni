//==============================================================================
// EXPRESSION STUFF

// LeftAssocSuffix  ((a++)++)
// RightAssocPrefix (++(++a))
// LeftAssocInfix   ((a-b)-c)
// RightAssocInfix  (a=(b=c))

template<typename N, typename P, typename O>
struct LeftAssocInfix {
  static const Token* match(const Token* a, const Token* b) {
    auto old_top = node_stack.top();

    auto end = P::match(a, b);
    if (!end) {
      // No node match, can't do anything.
      return nullptr;
    }

    while(1) {
      end = O::match(end, b);
      if (!a) {
        // Node match but no op, return the match.
        return end;
      }
      end = P::match(end, b);
      if (!end) {
        // Left node and op match, but no right node match.
        // Can't proceed, clear the failed match and return.
        node_stack.clear_to(old_top);
        return nullptr;
      }

      // Matched P-O-P, group them together into a N and continue matching.
      auto new_top = node_stack.top();
      assert((new_top - old_top) == 3);
      auto node = new N(a, end, &node_stack._stack[old_top], new_top - old_top);
      node_stack.pop_to(old_top);
      node_stack.push(node);
      a = end;
    }
  }
};

//------------------------------------------------------------------------------
// Matches strings of punctuation

template<StringParam lit>
struct Operator {

  static const Token* match(const Token* a, const Token* b) {
    if (!a || a == b) return nullptr;
    if (a + sizeof(lit.value) > b) return nullptr;

    for (auto i = 0; i < lit.len; i++) {
      if (!a[i].is_punct(lit.value[i])) return nullptr;
    }

    return a + sizeof(lit.value);
  }
};

//------------------------------------------------------------------------------

template<StringParam lit>
struct NodeOperator : public NodeBase {
  NodeOperator(const Token* a, const Token* b)
  : NodeBase(NODE_OPERATOR, a, b) {
  }

  static const Token* match(const Token* a, const Token* b) {
    if (auto end = Operator<lit>::match(a, b)) {
      node_stack.push(new NodeOperator(a, end));
      return end;
    }
    else {
      return nullptr;
    }
  }
};

//------------------------------------------------------------------------------
// All

/* 0  */ const Token* parse_expression_paren       (const Token* a, const Token* b);
/* 1  */ const Token* parse_expression_scope       (const Token* a, const Token* b);

/* 2  */ const Token* parse_expression_postincdec  (const Token* a, const Token* b);
/* 2  */ const Token* parse_expression_fcast       (const Token* a, const Token* b);
/* 2  */ const Token* parse_expression_call        (const Token* a, const Token* b);
/* 2  */ const Token* parse_expression_subscript   (const Token* a, const Token* b);
/* 2  */ const Token* parse_expression_member      (const Token* a, const Token* b);

/* 3  */ const Token* parse_expression_preincdec   (const Token* a, const Token* b);
/* 3  */ const Token* parse_expression_plusminus   (const Token* a, const Token* b);
/* 3  */ const Token* parse_expression_not         (const Token* a, const Token* b);
/* 3  */ const Token* parse_expression_cast        (const Token* a, const Token* b);
/* 3  */ const Token* parse_expression_dereference (const Token* a, const Token* b);
/* 3  */ const Token* parse_expression_addressof   (const Token* a, const Token* b);
/* 3  */ const Token* parse_expression_sizeof      (const Token* a, const Token* b);

/* 4  */ const Token* parse_expression_ptrtomember (const Token* a, const Token* b);
/* 5  */ const Token* parse_expression_muldivmod   (const Token* a, const Token* b);
/* 6  */ const Token* parse_expression_addsub      (const Token* a, const Token* b);
/* 7  */ const Token* parse_expression_shift       (const Token* a, const Token* b);
/* 8  */ const Token* parse_expression_threeway    (const Token* a, const Token* b);
/* 9  */ const Token* parse_expression_relational  (const Token* a, const Token* b);
/* 10 */ const Token* parse_expression_equality    (const Token* a, const Token* b);
/* 11 */ const Token* parse_expression_bitwise_and (const Token* a, const Token* b);
/* 12 */ const Token* parse_expression_bitwise_xor (const Token* a, const Token* b);
/* 13 */ const Token* parse_expression_bitwise_or  (const Token* a, const Token* b);
/* 14 */ const Token* parse_expression_logical_and (const Token* a, const Token* b);
/* 15 */ const Token* parse_expression_logical_or  (const Token* a, const Token* b);
/* 16 */ const Token* parse_expression_ternary     (const Token* a, const Token* b);
/* 16 */ const Token* parse_expression_assignment  (const Token* a, const Token* b);
/* 17 */ const Token* parse_expression_comma       (const Token* a, const Token* b);





//------------------------------------------------------------------------------

struct NodeExpressionParenthesized : public NodeMaker<NodeExpressionParenthesized> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_PAREN;

  using pattern = Seq<
    Atom<'('>,
    Ref<parse_expression>,
    Atom<')'>
  >;
};

const Token* parse_expression_paren(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionParenthesized,
    NodeConstant,
    NodeIdentifier
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionScope : public NodeMaker<NodeExpressionScope> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_SCOPE;

  using pattern =
  Seq<
    Ref<parse_expression_paren>,
    Some<Seq<
      NodeOperator<"::">,
      Ref<parse_expression_paren>
    >>
  >;
};

const Token* parse_expression_scope(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionScope,
    Ref<parse_expression_paren>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionPostIncDec : public NodeMaker<NodeExpressionPostIncDec> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_POSTINCDEC;

  using pattern =
  Seq<
    Ref<parse_expression_scope>,
    Some<
      Oneof<
        NodeOperator<"++">,
        NodeOperator<"--">
      >
    >
  >;
};

const Token* parse_expression_postincdec(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionPostIncDec,
    Ref<parse_expression_scope>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionFCast : public NodeMaker<NodeExpressionFCast> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_FCAST;

  using pattern =
  Seq<
    NodeDecltype,
    Operator<"{">,
    Ref<parse_expression>,
    Operator<"}">
  >;
};

const Token* parse_expression_fcast(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionFCast,
    Ref<parse_expression_postincdec>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionCall : public NodeMaker<NodeExpressionCall> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_CALL;

  using pattern =
  Seq<
    Ref<parse_expression_fcast>,
    // FIXME does this need Some<Seq<...>>? Will f()() parse OK?
    Operator<"(">,
    Ref<parse_expression>,
    Operator<")">
  >;
};

const Token* parse_expression_call(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionCall,
    Ref<parse_expression_fcast>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionSubscript : public NodeMaker<NodeExpressionSubscript> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_SUBSCRIPT;

  using pattern =
  Seq<
    Ref<parse_expression_call>,
    Some<Seq<
      Operator<"[">,
      Ref<parse_expression>,
      Operator<"]">
    >>
  >;
};

const Token* parse_expression_subscript(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionSubscript,
    Ref<parse_expression_call>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionMember : public NodeMaker<NodeExpressionMember> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_MEMBER;

  using pattern =
  Seq<
    Ref<parse_expression_subscript>,
    Some<Seq<
      Oneof<
        NodeOperator<".">,
        NodeOperator<"->">
      >,
      Ref<parse_expression_subscript>
    >>
  >;
};

const Token* parse_expression_member(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionMember,
    Ref<parse_expression_subscript>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionPreIncDec : public NodeMaker<NodeExpressionPreIncDec> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_PREINCDEC;

  using pattern =
  Seq<
    Oneof<
      NodeOperator<"++">,
      NodeOperator<"--">
    >,
    Ref<parse_expression_preincdec>
  >;
};

const Token* parse_expression_preincdec(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionPreIncDec,
    Ref<parse_expression_member>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionPlusMinus : public NodeMaker<NodeExpressionPlusMinus> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_PLUSMINUS;

  using pattern =
  Seq<
    Oneof<
      NodeOperator<"+">,
      NodeOperator<"-">
    >,
    Ref<parse_expression_plusminus>
  >;
};

const Token* parse_expression_plusminus(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionPlusMinus,
    Ref<parse_expression_preincdec>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionNot : public NodeMaker<NodeExpressionNot> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_NOT;

  using pattern =
  Seq<
    Oneof<
      NodeOperator<"!">,
      NodeOperator<"~">
    >,
    Ref<parse_expression_not>
  >;
};

const Token* parse_expression_not(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionNot,
    Ref<parse_expression_plusminus>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionCast : public NodeMaker<NodeExpressionCast> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_CAST;

  using pattern =
  Seq<
    Atom<'('>,
    NodeDecltype,
    Atom<')'>,
    Ref<parse_expression_cast>
  >;
};

const Token* parse_expression_cast(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionCast,
    Ref<parse_expression_not>
  >;
  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionDereference : public NodeMaker<NodeExpressionDereference> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_DEREFERENCE;

  using pattern = Seq<
    NodeOperator<"*">,
    Ref<parse_expression_dereference>
  >;
};

const Token* parse_expression_dereference(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionDereference,
    Ref<parse_expression_cast>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionAddressof : public NodeMaker<NodeExpressionAddressof> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_ADDRESSOF;

  using pattern = Seq<
    NodeOperator<"&">,
    Ref<parse_expression_addressof>
  >;
};

const Token* parse_expression_addressof(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionAddressof,
    Ref<parse_expression_dereference>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionSizeof : public NodeMaker<NodeExpressionSizeof> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_SIZEOF;

  using pattern = Seq<
    Keyword<"sizeof">,
    Oneof<
      Seq<Atom<'('>, NodeDecltype, Atom<')'>>,
      Ref<parse_expression_sizeof>
    >
  >;
};

const Token* parse_expression_sizeof(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionSizeof,
    Ref<parse_expression_addressof>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionPtrToMember : public NodeMaker<NodeExpressionPtrToMember> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_PTRTOMEMBER;

  using pattern = Seq<
    Ref<parse_expression_sizeof>,
    Some<Seq<
      Oneof<
        NodeOperator<"->*">,
        NodeOperator<".*">
      >,
      Ref<parse_expression_sizeof>
    >>
  >;
};

const Token* parse_expression_ptrtomember(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionPtrToMember,
    Ref<parse_expression_sizeof>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------
// FIXME associativity is wrong

struct NodeExpressionMulDivMod : public NodeMaker<NodeExpressionMulDivMod> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_MULDIVMOD;

  using pattern = Seq<
    Ref<parse_expression_ptrtomember>,
    Some<Seq<
      Oneof<
        NodeOperator<"*">,
        NodeOperator<"/">,
        NodeOperator<"%">
      >,
      Ref<parse_expression_ptrtomember>
    >>
  >;
};

const Token* parse_expression_muldivmod(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionMulDivMod,
    Ref<parse_expression_ptrtomember>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionAddSub : public NodeMaker<NodeExpressionAddSub> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_ADDSUB;

  using pattern = Seq<
    Ref<parse_expression_muldivmod>,
    Some<Seq<
      Oneof<
        NodeOperator<"+">,
        NodeOperator<"-">
      >,
      Ref<parse_expression_muldivmod>
    >>
  >;
};

const Token* parse_expression_addsub(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionAddSub,
    Ref<parse_expression_muldivmod>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionShift : public NodeMaker<NodeExpressionShift> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_SHIFT;

  using pattern = Seq<
    Ref<parse_expression_addsub>,
    Some<Seq<
      Oneof<
        NodeOperator<"<<">,
        NodeOperator<">>">
      >,
      Ref<parse_expression_addsub>
    >>
  >;
};

const Token* parse_expression_shift(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionShift,
    Ref<parse_expression_addsub>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionThreeway : public NodeMaker<NodeExpressionThreeway> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_THREEWAY;

  using pattern = Seq<
    Ref<parse_expression_shift>,
    Some<Seq<
      NodeOperator<"<=>">,
      Ref<parse_expression_shift>
    >>
  >;
};

const Token* parse_expression_threeway(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionThreeway,
    Ref<parse_expression_shift>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionRelational : public NodeMaker<NodeExpressionRelational> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_RELATIONAL;

  using pattern = Seq<
    Ref<parse_expression_threeway>,
    Some<Seq<
      Oneof<
        NodeOperator<"<=">,
        NodeOperator<">=">,
        NodeOperator<"<">,
        NodeOperator<">">
      >,
      Ref<parse_expression_threeway>
    >>
  >;
};

const Token* parse_expression_relational(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionRelational,
    Ref<parse_expression_threeway>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionEquality : public NodeMaker<NodeExpressionEquality> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_EQUALITY;

  using pattern = Seq<
    Ref<parse_expression_relational>,
    Some<Seq<
      Oneof<
        NodeOperator<"==">,
        NodeOperator<"!=">
      >,
      Ref<parse_expression_relational>
    >>
  >;
};

const Token* parse_expression_equality(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionEquality,
    Ref<parse_expression_relational>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionBitwiseAnd : public NodeMaker<NodeExpressionBitwiseAnd> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_BITWISE_AND;

  using pattern = Seq<
    Ref<parse_expression_equality>,
    Some<Seq<
      NodeOperator<"&">,
      Ref<parse_expression_bitwise_and>
    >>
  >;
};

const Token* parse_expression_bitwise_and(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionBitwiseAnd,
    Ref<parse_expression_equality>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionBitwiseXor : public NodeMaker<NodeExpressionBitwiseXor> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_BITWISE_XOR;

  using pattern = Seq<
    Ref<parse_expression_bitwise_and>,
    Some<Seq<
      NodeOperator<"^">,
      Ref<parse_expression_bitwise_and>
    >>
  >;
};

const Token* parse_expression_bitwise_xor(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionBitwiseXor,
    Ref<parse_expression_bitwise_and>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionBitwiseOr : public NodeMaker<NodeExpressionBitwiseOr> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_BITWISE_OR;

  using pattern = Seq<
    Ref<parse_expression_bitwise_xor>,
    Some<Seq<
      NodeOperator<"|">,
      Ref<parse_expression_bitwise_xor>
    >>
  >;
};

const Token* parse_expression_bitwise_or(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionBitwiseOr,
    Ref<parse_expression_bitwise_xor>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionLogicalAnd : public NodeMaker<NodeExpressionLogicalAnd> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_LOGICAL_AND;

  using pattern = Seq<
    Ref<parse_expression_bitwise_or>,
    Some<Seq<
      NodeOperator<"&&">,
      Ref<parse_expression_bitwise_or>
    >>
  >;
};

const Token* parse_expression_logical_and(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionLogicalAnd,
    Ref<parse_expression_bitwise_or>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionLogicalOr : public NodeMaker<NodeExpressionLogicalOr> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_LOGICAL_OR;

  using pattern = Seq<
    Ref<parse_expression_logical_and>,
    Some<Seq<
      NodeOperator<"||">,
      Ref<parse_expression_logical_and>
    >>
  >;
};

const Token* parse_expression_logical_or(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionLogicalOr,
    Ref<parse_expression_logical_and>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionTernary : public NodeMaker<NodeExpressionTernary> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_TERNARY;

  using pattern = Seq<
    Ref<parse_expression_logical_or>,
    NodeOperator<"?">,
    Ref<parse_expression_ternary>,
    NodeOperator<":">,
    Ref<parse_expression_ternary>
  >;
};

const Token* parse_expression_ternary(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionTernary,
    Ref<parse_expression_logical_or>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------

struct NodeExpressionAssignment : public NodeMaker<NodeExpressionAssignment> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_ASSIGNMENT;

  using pattern =
  Seq<
    Ref<parse_expression_ternary>,
    Some<Seq<
      Oneof<
        NodeOperator<"<<=">,
        NodeOperator<">>=">,
        NodeOperator<"+=">,
        NodeOperator<"-=">,
        NodeOperator<"*=">,
        NodeOperator<"/=">,
        NodeOperator<"%=">,
        NodeOperator<"&=">,
        NodeOperator<"|=">,
        NodeOperator<"^=">,
        NodeOperator<"=">
      >,
      Ref<parse_expression_ternary>
    >>
  >;
};

const Token* parse_expression_assignment(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionAssignment,
    Ref<parse_expression_ternary>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------
// left-assoc

struct NodeExpressionComma : public NodeMaker<NodeExpressionComma> {
  using NodeMaker::NodeMaker;
  static const NodeType node_type = NODE_EXPRESSION_COMMA;

  using pattern = Seq<
    Ref<parse_expression_assignment>,
    Some<Seq<
      NodeOperator<",">,
      Ref<parse_expression_assignment>
    >>
  >;

};

const Token* parse_expression_comma(const Token* a, const Token* b) {
  using pattern = Oneof<
    NodeExpressionComma,
    Ref<parse_expression_assignment>
  >;

  return pattern::match(a, b);
}

//------------------------------------------------------------------------------
// We need a shunting yard algorithm....

const Token* parse_expression(const Token* a, const Token* b) {
  using pattern = Ref<parse_expression_comma>;

  return pattern::match(a, b);
}

//==============================================================================
