<!doctype html>
<html lang="en-us">

<head>
  <script src="assets/drawdown.js"></script>
  <link rel="stylesheet" href="top.css" />

  <title>Matcheroni & Parseroni</title>
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">

</head>

<body>

<pre class="plain" style="display:none;">

# Matcheroni Documentation

[Matcheroni](https://github.com/aappleby/Matcheroni/blob/main/matcheroni/Matcheroni.hpp) is a minimalist, zero-dependency, single-header C++20 library for doing pattern matching using [Parsing Expression Grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar) (PEGs). PEGs are similar to regular expressions, but both more and less powerful.

[Parseroni](https://github.com/aappleby/Matcheroni/blob/main/matcheroni/Parseroni.hpp) is a companion single-header library that can capture the content of Matcheroni patterns and assemble them into concrete [parse trees](https://en.wikipedia.org/wiki/Parse_tree).

Matcheroni and Parseroni generate tiny, fast parsers that are easy to customize and integrate into your existing codebase.

# Tutorial

[Check out the tutorial here](tutorial/) - it will walk you through building a JSON parser using Matcheroni and Parseroni.

# Quick Reference

| Regex Syntax | Matcheroni Syntax | Regex Example | Matcheroni Example |
| ----------- | ----------- | ----------- | ----------- |
| (single char) | Atom&lt;char&gt; | /a/ | Atom&lt;'a'&gt; |
| (literal string) | Lit&lt;string&gt; | /foobar/ | Lit&lt;"foobar"&gt; |
| (sequence of patterns) | Seq&lt;...&gt; | /abc/ | Seq&lt;Atom&lt;'a'&gt;, Atom&lt;'b'&gt;, Atom&lt;'c'&gt;&gt; |
| pattern* | Any&lt;pattern&gt; | /a*/ | Any&lt;Atom&lt;'a'&gt;&gt; |
| pattern+ | Some&lt;pattern&gt; | /a+/ | Some&lt;Atom&lt;'a'&gt;&gt;  |
| pattern? | Opt&lt;pattern&gt; | /a?/ | Opt&lt;Atom&lt;'a'&gt;&gt; |
| [a-z] | Range&lt;'a','z'&gt; |
| [a-zA-Z0-9] | Range&lt;'a','z','A','Z','0','9'&gt;|
| [^a-z] | NotRange&lt;'a','z'&gt; |
| (a\|b) | Oneof&lt;a,b&gt; |

<br>

| PEG            | Regex       | Matcheroni                | Description |
| -------------- | ----------- | ------------------------- | ----------- |
| Terminal       |             | Atom&lt;&gt;, Lit&lt;&gt; |             |
| Sequence       |             |                           |             |
| Ordered Choice |             |                           |             |
| Zero-or-more   |             |                           |             |
| One-or-more    |             |                           |             |
| Optional       |             |                           |             |
| And-predicate  |             |                           |             |
| Not-predicate  |             |                           |             |



- ```Atom<x, y, ...>``` matches any single "atom" of your input that is equal to one of the template parameters. Atoms can be characters, objects, or whatever as long as you implement ```atom_cmp(...)``` for them. Atoms "consume" input and advance the read cursor when they match.
- ```Seq<x, y, ...>``` matches sequences of other matchers.
- ```Oneof<x, y, ...>``` returns the result of the first successful sub-matcher. Like parsing expression grammars, there is no backtracking - if ```x``` matches, we will never back up and try ```y```.
- ```Any<x>``` is equivalent to ```x*``` in regex - it matches zero or more instances of ```x```.
- ```Some<x>``` is equivalent to ```x+``` in regex - it matches one or more instances of ```x```.
- ```Opt<x>``` is equivalent to ```x?``` in regex - it matches exactly 0 or 1 instances of ```x```.
- ```And<x>``` matches ```x``` but does _not_ advance the read cursor.
- ```Not<x>``` matches if ```x``` does _not_ match and does _not_ advance the read cursor.


# Recipes





# Examples
Matcheroni patterns are roughly equivalent to regular expressions. A regular expression using the std::regex C++ library
```cpp
std::regex my_pattern("[abc]+def");
```
would be expressed in Matcheroni as
```cpp
using my_pattern = Seq&lt;Some&lt;Atom&lt;'a','b','c'&gt;&gt;, Lit&lt;"def"&gt;&gt;;
```
In the above line of code, we are defining the matcher "my_pattern" by nesting the Seq<>, Some<>, Atom<>, and Lit<> matcher templates. The resuling type (not instance) defines a static "match()" function that behaves similarly to the regex.

Unlike std::regex, we don't need to link in any additional libraries or instantiate anything to use it:
```cpp
const std::string text = "aaabbaaccdefxyz";

// The first argument to match() is a reference to a context object.
// The second two arguments are the range of text to match against.
// The match function returns the _end_ of the match, or nullptr if there was no match.
TextMatchContext ctx;
TextSpan tail = my_pattern::match(ctx, to_span(text));

// Since we matched "aabbaaccdef", this prints "xyz".
printf("%s\n", result);
```

Matchers are also modular - you could write the above as
```cpp
using abc = Atom&lt;'a','b','c'&gt;;
using def = Lit&lt;"def"&gt;;
using my_pattern = Seq&lt;Some&lt;abc&gt;, def&gt;;
```
and it would perform identically to the one-line version.

Unlike regexes, matchers can be recursive. Note that you can't nest a pattern inside itself directly, as "using pattern" doesn't count as a declaration. Forward-declaring a matcher function and using that in a pattern works though (and you can refer to the "using" declaration before it's declared):
```cpp

static TextSpan match_parens(TextMatchContext& ctx, TextSpan body) {
  return Seq&lt;Atom&lt;'('&gt;, Any&lt;parens, NotAtom&lt;')'&gt;&gt;, Atom&lt;')'&gt;&gt;::match(ctx, body);
}
using parens = Ref&lt;match_parens&gt;;

// Now we can use the pattern
std::string text = "(((foo)bar)baz)tail";
TextMatchContext ctx;
TextSpan tail = parens::match(ctx, to_span(text));
printf("%s", tail); // prints "tail"
```




</pre>

<div class="markdown"></div>

<script>
  let ein = document.querySelector(".plain")
  let eout = document.querySelector(".markdown")
  eout.innerHTML = markdown(ein.innerText)
</script>

</body>
