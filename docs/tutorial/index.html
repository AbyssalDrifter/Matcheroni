<!doctype html>
<html lang="en-us">

<head>
  <script type="text/javascript">
    console.log("page load starting @ " + performance.now());
  </script>
  <link rel="stylesheet" href="tutorial.css" />
  <link rel="stylesheet" href="../assets/vs2015.min.css" />

  <script src="../assets/highlight.min.js"></script>
  <script src="../assets/ansi_up.js"></script>

  <title>Metron C++ to Verilog Tutorial</title>
  <link rel="icon" type="image/x-icon" href="../assets/cheese_m.jpg">

</head>

<body>
<div class="topbar">
  <div class="topbar_spacer"> </div>
  <div class="topbar_title">
    <img src="../assets/cheese_m.jpg" width="48" height="48" style="margin:8px;">
    Matcheroni & Parseroni Tutorial
    <a style="margin-left:80px;" href="https://github.com/aappleby/Matcheroni">Source on Github</a>
  </div>
  <div class="topbar_spacer"></div>
</div>

<div class="contents">

<div class="divider">Matcheroni & Parseroni - Quick and Easy Parsing in C++20</div>

<p>
  <a href="https://github.com/aappleby/Matcheroni/blob/main/matcheroni/Matcheroni.hpp">Matcheroni</a> is a minimalist, zero-dependency, single-header C++20 library for doing pattern matching using <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammars (PEGs)</a>. PEGs are similar to regular expressions, but both more and less powerful.
<p>
  <a href="https://github.com/aappleby/Matcheroni/blob/main/matcheroni/Parseroni.hpp">Parseroni</a> is a companion single-header library that can capture the content of Matcheroni patterns and assemble them into concrete <a href="https://en.wikipedia.org/wiki/Parse_tree">parse trees</a>.
</p>
<p>
  In this tutorial, we'll be using Matcheroni and Parseroni to build a JSON parser in less than 100 lines of code.
</p>























<div class="divider">Parsing JSON, Step 0: "Hello World"</div>

<p>
But before we jump into JSON syntax, let's start with the Matcheroni equivalent of "Hello World".
</p>
<p>
The code below is exactly as it appears in the Matcheroni repo and has been compiled into WASM via Emscripten. The panels on the right are live - type into the top box and you'll see the program's output in the lower box.
</p>

<div class="live_code" id="json_tut0a">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut0a.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut0a.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut0a output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>Let's go through this line-by-line once and we'll then skip over the details in the later tutorials.</p>

<pre class="centered code_box language-cpp">
#include "matcheroni/Matcheroni.hpp"
#include "matcheroni/Utilities.hpp"

using namespace matcheroni;
</pre>

<p>
  We're including <span class="highlight">Matcheroni.hpp</span> and <span class="highlight">Utilities.hpp</span>, which contains various helper functions that make testing easier. The main code is in the <span class="highlight">matcheroni</span> namespace, utilities are in <span class="highlight">matcheroni::utils</span>, and there are prefab patterns for various matching tasks in the <span class="highlight">matcheroni::cookbook</span> namespace.
</p>

<pre class="centered code_box language-cpp">
  std::string input = utils::read(argv[1]);
  TextSpan text = utils::to_span(input);
</pre>

<p>
Matcheroni operates on spans of atoms, which are roughly equivalent to slices in Rust or Python. In this case our atoms are just characters, though they could be any type. <span class="highlight">TextSpan</span> is just a typedef for <span class="highlight">matcheroni::Span&lt;char&gt;</span>.
</p>
<pre class="centered code_box language-cpp">
  using pattern = Seq< Lit<"Hello">, Atom<' '>, Lit<"World"> >;
</pre>

<p>
The pattern we're matching is a sequence consisting of the literal string "Hello", followed by a single space, followed by the literal string "World". Our pattern expresses that in Matcheroni syntax.<br>
</p>

<pre class="centered code_box language-cpp">
  TextMatchContext ctx;
</pre>

<p>
  Matcheroni patterns are themselves stateless, but in most non-trivial uses of Matcheroni we're going to want to keep track of some application-specific context. Matcheroni's <span class="highlight">TextMatchContext</span> is a convenience class that contains the minimal amount of code needed to make things work.
</p>

<pre class="centered code_box language-cpp">
struct TextMatchContext {

  // We cast to unsigned char as our ranges are generally going to be unsigned.
  static int atom_cmp(char a, int b) { return (unsigned char)a - b; }

  // Checkpoint/Rewind does nothing as it doesn't interact with trace_depth.
  void* checkpoint() { return nullptr; }
  void rewind(void* bookmark) {}

  // Tracing requires us to keep track of the nesting depth in the context.
  int trace_depth = 0;
};
</pre>

<p>
  You are free to provide your own context object as long as it implements three functions that Matcheroni requires - <span class="highlight">atom_cmp()</span> to compare atoms (ala strcmp()), <span class="highlight">checkpoint()</span> to generate an opaque token representing the current context's state, and <span class="highlight">rewind()</span> to restore the context to a previous state. <span class="highlight">TextMatchContext</span> has no state to save or restore, so its <span class="highlight">checkpoint()</span> and <span class="highlight">rewind()</span> are no-ops.
</p>


<pre class="centered code_box language-cpp">
  TextSpan tail = pattern::match(ctx, text);
</pre>

<p>
The 'tail' return value from pattern::match() is a span representing the <span class="highlight">_remainder_</span> of the input text if the pattern matched, or a <span class="highlight">(nullptr, &lt;match failure location&gt;)</span> pair if the pattern did not match.
</p>

<pre class="centered code_box language-cpp">
  utils::print_summary(text, tail, 50);
</pre>

<p>
  And 'print_summary' just displays a colorized version of the match results.
</p>


<div class="question">
Hey, wait a second - what _is_ 'pattern', exactly?<br>
It looks like a type, but there are words in it.
</div>
<p>
We can get into it in more detail later, but essentially the pattern is just a tree of templated structs, each of which has a static <span class="highlight">match()</span> method that does some matching work of its own and then calls into the <span class="highlight">match()</span> methods of the template arguments.</p>
<p>
When we call <span class="highlight">pattern::match(ctx, text)</span>, we're calling into the outermost sequence template's <span class="highlight">Seq&lt;&gt;::match()</span>, which then calls into <span class="highlight">Lit&lt;&gt;::match()</span>, then <span class="highlight">Atom&lt;&gt;::match()</span>, and so on. The strings "Hello", "World", and the space character are arguments to the terminal templates so that the instantiated match() methods have something to compare against.
</p>
<p>
Yeah, it's a bit weird - but it works quite well. The resulting template names are enormous, but the code is tiny and surprisingly fast - nearly as fast as what you'd get if you wrote a recursive-descent parser by hand, except with (hopefully) fewer bugs.<br>
</p>









<div class="divider">Parsing JSON, Step 1: Matching Numbers</div>

<p>
Now for a real-world example - parsing JSON. We'll break the grammar into a few chunks to make it a bit less overwhelming. Below we've defined a struct <span class="highlight">JsonMatcher</span> that uses the built-in Matcheroni patterns to match JSON-valid numbers. The grammar below is slightly modified from the version on <a href="http://json.org">JSON.org</a> (for reasons that will be explained later FIXME explain) but is equivalent to it.
</p>

<div class="live_code" id="json_tut1a">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut1a.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut1a.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut1a output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
  If you're familiar with regular expressions this should be easy to decipher. <span class="highlight">Range&lt;a,z&gt;</span> is <span class="highlight">[a-z]</span>, <span class="highlight">Some&lt;x&gt;</span> is <span class="highlight">x+</span>,
  <span class="highlight">Any&lt;x&gt;</span> is <span class="highlight">x*</span>, <span class="highlight">Opt&lt;x&gt;</span> is <span class="highlight">x?</span>, etecetera. Unlike regular expressions, we can break up our pattern into named reusable pieces - the Matcheroni patterns aren't as concise as regular expressions, but they're easier to read.
</p>
<p>
The static member function <span class="highlight">JsonMatcher::match()</span> is a "matcher function" in Matcheroni speak. Matcher functions can do whatever they want, but they must have this function signature:
</p>
<pre class="centered code_box language-cpp">
template &lt;typename context, typename atom&gt;
using matcher_function = Span&lt;atom&gt; (*)(context& ctx, Span&lt;atom&gt; body);</pre>
<p>
  Structs that implement a static <span class="highlight">match()</span> method with this signature can be incorporated into other Matcheroni patterns just like the built-in ones: <span class="highlight">Seq&lt;Some&lt;JsonMatcher&gt;...&gt;</span>. Being able to re-use chunks of a grammar in that fashion can be quite handy.
</p>
<p>
  Do note that we're not converting the matched string to a floating-point number, only verifying that the input string matches the number pattern defined in the JSON spec. Handling data conversion is farther down in this tutorial.
</p>


<div class="divider">Parsing JSON, Step 2: Matching Strings & Keywords</div>
<p>
  With numbers taken care of, we can try matching strings and keywords. These are slightly more complicated than numbers, but the patterns here are still almost identical to the <a href="http://json.org">JSON.org</a> versions. We'll also extend <span class="highlight">JsonMatcher::match()</span> to handle whitespace-delimited sequences of numbers, strings, and keywords.
</p>

<div class="live_code" id="json_tut1b">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut1b.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut1b.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut1b output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
  There's a couple interesting things to look at here. The <span class="highlight">hex</span> pattern uses multiple ranges in one template just like <span class="highlight">[0-9a-fA-F]</span> in regex. The <span class="highlight">escape</span> pattern uses <span class="highlight">Charset&lt;&gt;</span> which is just a more concise <span class="highlight">Atom&lt;...&gt;</span> and <span class="highlight">Rep&lt;&gt;</span> which is equivalent to regex's <span class="highlight">a{N}</span>.
</p>
<p>
  That <span class="highlight">Range&lt;0x0020, 0x10FFFF&gt;</span> though - we're matching plain 8-bit characters, so why the huge constant? Well, that's what's in the JSON spec, and we're not actually matching 8-bit characters... yet.
</p>
<p>
  Something you might not have noticed is that nowhere in our Matcheroni patterns do we mention characters or bytes or any concrete type aside from the implicit type of the embedded constants themselves. The key that binds a Matcheroni pattern to an actual atom type is the <span class="highlight">atom_cmp()</span> method of the context mentioned earlier.
</p>
<p>
  The <span class="highlight">Atom&lt;&gt;</span> pattern doesn't match characters, it matches atoms - and atoms are anything that can be compared using the <span class="highlight">atom_cmp()</span> method provided in the context. So if we wanted to match floating point numbers using <span class="highlight">Atom&lt;3.14159&gt;</span> and <span class="highlight">static int atom_cmp(float a, float b)</span>, that would work equally as well as matching characters.
</p>
<p>
  Similarly, if the matcher function's signature was something like <span class="highlight">static UTF32Span match(UTF32MatchContext& ctx, UTF32Span body)</span>, we could pass in UTF-32-encoded text and the matcher will do the right thing (or at least it should, I haven't checked this particular case yet).
</p>
<p>
  The (work-in-progress) C99 lexer and parser in Matcheroni's example folder takes advantage of this functionality - the lexer matches plain text and produces tokens, the parser matches tokens and produces parse nodes. There are probably other interesting ways of using Matcheroni on things other than text - perhaps parsing binary data, or decoding bus transactions from oscilloscope data?
</p>

<div class="divider">JSON Part 3: Matching Containers</div>

<p>
  To finish out the JSON grammar, we need to add support for arrays and dictionaries. We also need a generic <span class="highlight">value</span> pattern that can match any possible value in a key-value pair. While we're at it, we'll add debugging support using the <span class="highlight">utils::TraceText&lt;&gt;</span> template.
</p>
<div class="live_code" id="json_tut1c">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut1c.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut1c.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut1c output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
  If you intentionally add some garbage to the input JSON, you'll see in the trace where the matcher fails.
</p>

<p>
  Code-wise, we've got lots of things to look at here. First off, we declare a templated pattern <span class="highlight">list&lt;&gt;</span> so that we can make comma-delimited lists out of our other patterns. Factoring out small patterns like this helps readability in larger programs.
</p>

<p>
  Next we... define a static <span class="highlight">match_value()</span> function that matches types that haven't been declared yet? Yep, that's valid, and it's how we handle recursive patterns.
</p>

<p>
  JSON objects can contain values and JSON values can be objects - the JSON grammar is recursive by definition through the <span class="highlight">value</span> pattern. C++ templates, however, cannot contain themselves as arguments. Instead, we define a static matcher function <span class="highlight">match_value()</span> and wrap it in a <span class="highlight">Ref&lt;&gt;</span> template, which is one of the ways that Matcheroni can call user-defined code.
</p>
<p>
  Member functions are allowed (due to C++ reasons I do not understand) to refer to types in their parent class even before they've been declared. So we can replace template-recursion with call-recursion and everything still compiles. The <span class="highlight">Ref&lt;&gt;</span> template can also call functions on your Context object if needed. More on that later FIXME write this.
</p>
<p>
  With <span class="highlight">value</span> and <span class="highlight">list&lt;&gt;</span> defined, the <span class="highlight">array</span> and <span class="highlight">object</span> patterns aren't too complicated - we match the outermost delimiters surrounding optional whitespace and a comma-delimited list of values or key/value pairs.
</p>
<p>
  To debug our patterns, we can wrap them in <span class="highlight">utils::TraceText&lt;"identifier", pattern&gt;</span>. This will print out a representation of the match state before and after each match() call, as you can see on the right. Tracing generates a _lot_ of output though, so use it sparingly.
</p>

<div class="divider">Parsing JSON, Step 4: Actually Parsing JSON</div>

<p>
  Our JSON matcher works, but we need a JSON _parser_ that will build a parse tree we can iterate over and do useful things with. <a href="https://github.com/aappleby/Matcheroni/blob/main/matcheroni/Parseroni.hpp">Parseroni.hpp</a> provides helper code that makes this fairly straightforward. Parseroni consists of three main parts:
</p>
<p><span class="highlight">NodeBase&lt;&gt;</span> is a mixin-style parse node base class that stores the child/sibling pointers for each parse node, along with a tag string and the span from the matcher.</p>
<p><span class="highlight">NodeContext&lt;&gt;</span> handles all the pointer bookkeeping needed to create parse trees and uses a specialized allocator to minimize the overhead of creating and destroying parse nodes as we work through all our possible matches.</p>
<p><span class="highlight">Capture&lt;&gt;</span> wraps Matcheroni patterns in the same way as <span class="highlight">Trace&lt;&gt;</span> and tells <span class="highlight">NodeContext&lt;&gt;</span> to create a new <span class="highlight">NodeBase&lt;&gt;</span> and add it to the parse tree if the pattern inside it matches.</p>

<p>For convenience, Parseroni provides specialized versions of these for the common case of matching plain text:</p>

<pre class="centered code_box language-cpp">
// Note that NodeBase&lt;&gt; is a mixin-style class, which means that class X must
// inherit from template&lt;X, ...&gt;.
struct TextParseNode : public NodeBase&lt;TextParseNode, char&gt; {

  // Returns a text representation of this node's contents for debugging.
  // Implementing this method is optional, but print_summary() and similar
  // won't work without it.
  TextSpan as_text() const { return span; }
};

// The return value of atom_cmp() must follow strcmp() rules. You can implement
// atom_cmp() multiple times if you have more types of constants to match
// against.
struct TextParseContext : public NodeContext&lt;TextParseNode&gt; {
  static int atom_cmp(char a, int b) {
    return (unsigned char)a - b;
  }
};
</pre>

<p>
And capturing a pattern with them looks like this:
</p>

<pre class="centered code_box language-cpp">
// Matches a key:value pair where 'key' is a string and 'value' is a JSON value.
using pair =
Seq&lt;
  Capture&lt;"key", string, TextParseNode&gt;,
  Opt&lt;space&gt;,
  Atom&lt;':'&gt;,
  Opt&lt;space&gt;,
  Capture&lt;"value", value, TextParseNode&gt;
&gt;;
</pre>

<p>
  If we take the code from the previous example and swap out <span class="highlight">Trace&lt;&gt;</span> with <span class="highlight">Capture&lt;&gt;</span> and <span class="highlight">TextMatchContext</span> with <span class="highlight">TextParseContext</span>, our matcher is now a parser and <span class="highlight">print_summary()</span> can dump out a visualization of the parse tree:
</p>


<div class="live_code" id="json_tut2a">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut2a.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut2a.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut2a output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
And that's it, we have a JSON parser in under 100 lines of code. We could probably code-golf it down smaller, but the readability of this version is nice.
</p>
<p>
FIXME blurb here about JSON conformance
</p>



<div class="divider">Parsing JSON, Step 5: Customization</div>
<p>
So great, we have a JSON parser. It's not very convenient to use though, as it doesn't do any automatic conversion of text into data types like "number" -> float.
</p>
<p>
Earlier I mentioned that Parseroni can make use of user-defined classes for nodes and contexts. Let's create some simple extensions of <span class="highlight">NodeBase&lt;&gt;</span> and <span class="highlight">NodeContext&lt;&gt;</span> so that we have nodes that can contain floating-point numbers instead of just text. We'll replace <span class="highlight">TextParseContext/TextParseNode</span> with our new <span class="highlight">JsonContext/JsonNode</span>, specialize <span class="highlight">JsonNode</span> to create a <span class="highlight">NumberNode</span>, and then make <span class="highlight">Capture&lt;&gt;</span> create <span class="highlight">NumberNode</span>s when it matches a number.
</p>
<div class="live_code" id="json_tut2b">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut2b.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut2b.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut2b output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
So now we have our own node and context classes, plus a <span class="highlight">NumberNode</span> that derives from <span class="highlight">JsonNode</span> and calls <span class="highlight">atoi()</span> on the text span it receives. To make use of <span class="highlight">NumberNode</span>, we just have to pass it as the third template argument to <span class="highlight">Capture&lt;&gt;</span>.

Yes, this example is a bit silly, but it illustrates how to start building out your own node types and integrating them into an existing grammar.
</p>


<div class="divider">Code Size & Performance</div>

<p>
  Let's see how much code our JSON parser has generated. Since it compiles down to a whole bunch of tiny functions that get inlined heavily, this is slightly awkward to measure. We can instead compare binary sizes between a version of main() that uses JsonParser::match(), and one that uses Atom&lt;'a'&gt;::match().
</p>

<pre class="centered text_box">
(Compiled with -O3 -flto)

Atom&lt;'a'&gt;::match()
~/Matcheroni$ size bin/tutorial/json_tut1c
   text    data     bss     dec     hex filename
   6102     768       8    6878    1ade bin/tutorial/json_tut1c

JsonParser::match()
~/Matcheroni$ size bin/tutorial/json_tut1c
   text    data     bss     dec     hex filename
  14257     768       8   15033    3ab9 bin/tutorial/json_tut1c

JsonParser::match() (with tracing)
~/Matcheroni$ size bin/tutorial/json_tut1c
   text    data     bss     dec     hex filename
  30320     768       8   31096    7978 bin/tutorial/json_tut1c
</pre>

<p>
So our JSON matcher generates a little over 8k of code. Tracing adds another 16k on top of that, which is more than I would expect but since it's for debugging I'm probably not going to investigate.
</p>

<p>
  What about performance?
</p>







<div class="divider">Pitfalls & Caveats</div>
<div class="question">Oneof&lt;&gt; returns the _first_ match</div>
<div class="question">Some&lt;Opt&lt;&gt;&gt; creates an infinite loop</div>
<div class="question">Suffixes can cause exponential parsing time</div>









<div class="divider">Work-In-Progress C Parser</div>

<p>Tiny C parser</p>
<div class="live_code" id="tiny_c_parser">
  <div class="left_panel">
    <div class="header_bar">./tutorial/tiny_c_parser.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/tiny_c_parser.input</div>
    <div class="input_pane language-cpp"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">tiny_c_parser output</div>
    <div class="output_pane"></div>
  </div>
</div>











<div class="divider">FAQs</div>
    <div class="question">
      Question from reader?
    </div>
    <p>
      Response thingy.
    </p>
    <p>
      <b>Warning and stuff</b>
    </p>


    <div class="divider">Closing remarks</div>
    <p>
      Stuff about Matcheroni
    </p>
    <p>
      -Austin Appleby
    </p>
  </div>


  <script type="text/javascript">
    console.log("source load starting @ " + performance.now());
  </script>
  <script type="module" src="tutorial.js"></script>
</body>

</html>
