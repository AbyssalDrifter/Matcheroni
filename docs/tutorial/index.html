<!doctype html>
<html lang="en-us">

<head>
  <script type="text/javascript">
    console.log("page load starting @ " + performance.now());
  </script>
  <link rel="stylesheet" href="tutorial.css" />
  <link rel="stylesheet" href="../assets/vs2015.min.css" />

  <script src="../assets/highlight.min.js"></script>
  <script src="../assets/ansi_up.js"></script>

  <title>Metron C++ to Verilog Tutorial</title>
  <link rel="icon" type="image/x-icon" href="../assets/cheese_m.jpg">

</head>

<body>
<div class="topbar">
  <div class="topbar_spacer"> </div>
  <div class="topbar_title">
    <img src="../assets/cheese_m.jpg" width="48" height="48" style="margin:8px;">
    Matcheroni & Parseroni Tutorial
    <a style="margin-left:80px;" href="https://github.com/aappleby/Matcheroni">Source on Github</a>
  </div>
  <div class="topbar_spacer"></div>
</div>

<div class="contents">

<div class="divider">Matcheroni is a pattern-matching toolkit.</div>

<p>
  Matcheroni is a minimalist, zero-dependency, single-header C++20 library for building pattern-matchers - similar to regular expressions, but both more and less powerful.
  It's based on
  <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">"Parsing Expression Grammars"</a> (PEGs), which are similar in concept to
  regular expressions but behave slightly differently.
</p>
<div class="divider">Parseroni uses Matcheroni to build parse trees.</div>
<p>
  Parseroni is a companion single-header library that can capture the content of Matcheroni patterns and assemble them into concrete parse trees.<br>
</p>
<p>
  Together the two are concise enough to build a JSON parser in less than a page of code, while still powerful enough to parse C99 with a few helper classes.
</p>























<div class="divider">Parsing JSON, Step 0: "Hello World"</div>

<p>
Before we jump into JSON syntax, let's start with the Matcheroni equivalent of "Hello World".
</p>
<p>
The code below is exactly as it appears in the Matcheroni repo and has been compiled into WASM via Emscripten. The panels on the right are live - type into the top box and you'll see the program's output in the lower box.
</p>

<div class="live_code" id="json_tut0a">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut0a.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut0a.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut0a output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>Let's go through this line-by-line once; we'll then skip over the details in the later tutorials.</p>

<pre class="centered code_box language-cpp">
#include "matcheroni/Matcheroni.hpp"
#include "matcheroni/Utilities.hpp"

using namespace matcheroni;
</pre>

<p>
  We're including Matcheroni.hpp and Utilities.hpp, which contains various helper functions that make testing easier. The main code is in the 'matcheroni' namespace, utilities are in 'matcheroni::utils', and there are prefab patterns for various matching tasks in the 'matcheroni::cookbook' namespace.
</p>

<pre class="centered code_box language-cpp">
  std::string input = utils::read(argv[1]);
  TextSpan text = utils::to_span(input);
</pre>

<p>
We read the contents of argv[1] into a string, wrap it in a TextSpan, and do some pattern matching on it.
</p>

<pre class="centered code_box language-cpp">
  using pattern = Seq< Lit<"Hello">, Atom<' '>, Lit<"World"> >;
</pre>

<p>
The pattern we're matching is a sequence consisting of the literal string "Hello", followed by a single space, followed by the literal string "World". Our pattern expresses that in Matcheroni syntax.<br>
</p>

<pre class="centered code_box language-cpp">
  TextContext ctx;
</pre>


<p>
In most non-trivial uses of Matcheroni, we're going to want to keep track of some application-specific context. Context objects _must_ implement two methods - 'atom_cmp' so that Matcheroni knows how to compare two atoms, and 'rewind' to reset the state of the context object when a partial match fails. Matcheroni provides a trivial 'TextContext' that is sufficient for matching plain text.
</p>

<pre class="centered code_box language-cpp">
  TextSpan tail = pattern::match(ctx, text);
</pre>

<p>
The 'tail' return value from pattern::match() is a span representing the <b>remainder</b> of the input text if the pattern matched, or a (nullptr, &lt;match failure location&gt;) pair if the pattern did not match.
</p>

<pre class="centered code_box language-cpp">
  utils::print_summary(text, tail, 50);
</pre>

<p>
  And 'print_summary' just displays a colorized version of the match results.
</p>


<div class="question">
Hey, wait a second - what _is_ the pattern matcher, exactly?<br>
It's "using" what looks like a type, but there are words in it.
</div>
<p>
We can get into it in more detail later, but essentially the matcher is just a tree of templated structs, each of which has a static match() method that does some matching work of its own and then calls into the match() methods of the template arguments.</p>
<p>
When we call pattern::match(ctx, text), we're calling into the outermost Seq&lt;&gt; (sequence) template's match(), which then calls into Lit&lt;&gt;'s match(), then Atom&lt;&gt;'s match(), and so on. The strings "Hello", "World", and the space character are arguments to the terminal matchers so that the instantiated match() methods have something to compare against.
</p>
<p>
Yeah, it's a bit weird - but it works quite well. The resulting template names are enormous, but the code is tiny and surprisingly fast - nearly as fast as what you'd get if you wrote a recursive-descent parser by hand, except with (hopefully) fewer bugs.<br>
</p>









<div class="divider">Parsing JSON, Step 1: Matching Numbers</div>

<p>
Let's look at a more realistic example - parsing JSON. We'll break the grammar into a few chunks to make it a bit less overwhelming. Below we've defined our own matcher, JsonParser, that uses the built-in Matcheroni patterns to match JSON-valid numbers. The grammar below is slightly modified from the version on <a href="http://json.org">JSON.org</a> (for reasons that will be explained later) but is equivalent to it.
</p>

<div class="live_code" id="json_tut1a">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut1a.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut1a.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut1a output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
  If you're familiar with regular expressions this should be easy to decipher. Range&lt;a,z&gt; is '[a-z]', Some&lt;x&gt; is 'x+', Opt&lt;x&gt; is 'x?', etecetera. Unlike regular expressions, we can break up our pattern into named reusable pieces - the Matcheroni patterns aren't as concise as regular expressions, but they're easier to read.
</p>
<p>
  Do note that we're not converting the matched string to a floating-point number, only verifying that the input string matches the number pattern defined in the JSON spec. Handling data conversion is farther down in this tutorial.
</p>

<p>
  Because JsonParser implements a static match() method with the same signature that Matcheroni uses, we could incorporate it into some other Matcheroni pattern like 'Seq&lt;Some&lt;JsonParser&gt;...'. Being able to re-use chunks of a grammar in that fashion can be quite handy.
</p>
<p>
  Now let's match lists of numbers, strings, and keywords:
</p>

<div class="divider">Parsing JSON, Step 2: Matching Strings & Keywords</div>

<div class="live_code" id="json_tut1b">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut1b.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut1b.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut1b output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
  There's a couple interesting things to look at here. The 'hex' pattern uses multiple ranges in one template just like '[0-9a-fA-F]' in regex. The 'escape' pattern uses Charset&lt;&gt; which is just a more concise Atom&lt;...&gt;.
</p>
<p>
  That Range&lt;0x0020,0x10FFFF&gt; though - we're matching plain 8-bit characters, so why the huge constant? Well, that's what's in the JSON spec - and we're not actually matching 8-bit characters yet. The match() methods in the Matcheroni templates are themselves templated - we could pass in a "UTF32Context" and a "UTF32Span" and the matcher will do the right thing (or at least it should, I haven't checked this particular case yet).
</p>
<p>
  The (work-in-progress) C99 lexer and parser in Matcheroni's example folder takes advantage of this functionality - the lexer matches plain text and produces text spans, the parser matches text spans and produces parse nodes. There are probably other interesting ways of using Matcheroni on things other than text - perhaps parsing binary data, or decoding bus transactions from oscilloscope data?
</p>

<div class="divider">JSON Part 3: Matching Containers</div>

<p>
  Let's fold in the remainder of the JSON grammar and look at how we can debug Matcheroni patterns.
</p>
<div class="live_code" id="json_tut1c">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut1c.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut1c.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut1c output</div>
    <div class="output_pane"></div>
  </div>
</div>

<p>
  Lots of things to look at here.
</p>

<p>
  First off, we declare a templated pattern 'list' so that we can make comma-delimited lists out of our other patterns. Factoring out small patterns like this helps readability in larger programs.
</p>

<p>
  Next we... define a static matcher function that matches types that haven't been declared yet? Yep, that's valid, and it's how we handle recursive patterns.
</p>

<p>
  JSON arrays can contain values and JSON values can be arrays - the JSON grammar is recursive by definition. C++ templates, however, cannot contain themselves as arguments. Instead, we define a static matcher function and wrap it in a Ref&lt;&gt; template, which is one of the ways that Matcheroni can call user-defined code. That function is allowed (due to C++ reasons I do not understand) to refer to types in its parent class even before they've been declared. So we can replace type-recursion with call-recursion and everything still works. The Ref&lt;&gt; template can also call functions on your Context object if needed. More on that later.
</p>

<p>
  To debug our patterns, we can wrap them in utils::TraceText&lt;"identifier", pattern&gt;. This will print out a representation of the matcher position before and after each match() call, as you can see on the right. Tracing generates a _lot_ of output though, so use it sparingly.
</p>

<p>
  Let's see how much code our JSON parser has generated. Since it compiles down to a whole bunch of tiny functions that get inlined heavily, this is slightly awkward to measure. We can instead compare binary sizes between a version of main() that uses JsonParser::match(), and one that uses Atom&lt;'a'&gt;::match().
</p>

<pre class="centered text_box">
(Compiled with -O3 -flto)

Atom&lt;'a'&gt;::match()
~/Matcheroni$ size bin/tutorial/json_tut1c
   text    data     bss     dec     hex filename
   6102     768       8    6878    1ade bin/tutorial/json_tut1c

JsonParser::match()
~/Matcheroni$ size bin/tutorial/json_tut1c
   text    data     bss     dec     hex filename
  14257     768       8   15033    3ab9 bin/tutorial/json_tut1c

JsonParser::match() (with tracing)
~/Matcheroni$ size bin/tutorial/json_tut1c
   text    data     bss     dec     hex filename
  30320     768       8   31096    7978 bin/tutorial/json_tut1c
</pre>

<p>
So our JSON matcher generates a little over 8k of code. Tracing adds another 16k on top of that, which is more than I would expect but since it's for debugging I'm probably not going to investigate.
</p>

<p>
  What about performance?
</p>

<div class="divider">Parsing JSON, Step 4: Actually Parsing JSON</div>

<p>
  Here's tutorial 2a:<br>
</p>
<div class="live_code" id="json_tut2a">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut2a.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut2a.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut2b output</div>
    <div class="output_pane"></div>
  </div>
</div>




<div class="divider">Parsing JSON, Step 5: Customization</div>
<p>
  Here's tutorial 2b:<br>
</p>
<div class="live_code" id="json_tut2b">
  <div class="left_panel">
    <div class="header_bar">./tutorial/json_tut2b.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/json_tut2b.input</div>
    <div class="input_pane language-json" contenteditable="true"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">json_tut2b output</div>
    <div class="output_pane"></div>
  </div>
</div>






<div class="divider">JSON Part 6: Pitfalls & Caveats</div>
<div class="question">Oneof&lt;&gt; returns the _first_ match</div>
<div class="question">Some&lt;Opt&lt;&gt;&gt; creates an infinite loop</div>
<div class="question">Suffixes can cause exponential parsing time</div>









<div class="divider">Work-In-Progress C Parser</div>

<p>Tiny C parser</p>
<div class="live_code" id="tiny_c_parser">
  <div class="left_panel">
    <div class="header_bar">./tutorial/tiny_c_parser.cpp</div>
    <div class="source_pane language-cpp"></div>
  </div>
  <div class="right_panel">
    <div class="input_header header_bar">./tutorial/tiny_c_parser.input</div>
    <div class="input_pane language-cpp"></div>
    <div class="spacer"></div>
    <div class="output_header header_bar">tiny_c_parser output</div>
    <div class="output_pane"></div>
  </div>
</div>











<div class="divider">FAQs</div>
    <div class="question">
      Question from reader?
    </div>
    <p>
      Response thingy.
    </p>
    <p>
      <b>Warning and stuff</b>
    </p>


    <div class="divider">Closing remarks</div>
    <p>
      Stuff about Matcheroni
    </p>
    <p>
      -Austin Appleby
    </p>
  </div>


  <script type="text/javascript">
    console.log("source load starting @ " + performance.now());
  </script>
  <script type="module" src="tutorial.js"></script>
</body>

</html>
